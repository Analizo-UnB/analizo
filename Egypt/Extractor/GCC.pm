package Egypt::Extractor::GCC;

=head1 NAME

Egypt::Extractor::GCC - egypt's extractor for GCC-generated intermediate files.

=head1 DESCRIPTION

The GCC extractor reads information from the intermediate files generated by
GCC after it compiles the source code. When using the GCC extractor, egypt
tools will traverse your directories for files matching F<*.rtl> and
F<*.expand>, and will parse them in order to obtain information.

The original egypt implementation by Andreas Gustafsson only supported
extracting information using GCC information. After major refactoring of the
code, that logic ended up in this module as a pluggable component for use
with egypt's current implementation.

=head1 GENERATING THE INPUT FILES

Compile the program or source file you want to create a call graph for
with gcc, adding the option "-dr" to CFLAGS.  This option causes gcc
to dump its intermediate code representation of each file it compiles
into a a file.

For example, the following works for many programs:

  make clean
  make CFLAGS=-dr

Depending on the GCC version, the RTL file for a source file F<foo.c>
may be called something like F<foo.c.rtl>, F<foo.c.00.rtl>, or
F<foo.c.00.expand>.

=head1 LIMITATIONS

Relying on GCC-suplied information brings two major drawbracks:

=over

=item
The dependencies are processed after compiling the code, so some
information is lost. For example functions or variables that are actually
implemented as macros (#define's) are not considered in the results.

=item
You have to compile the sources before extracting information. Depending on the
size of the project and how many times you need to extract the information, this
limitation will probably make this extractor not viable for you.

=back

=head1 SEE ALSO

L<gcc>, L<egypt>

=cut

use strict;
use warnings;

use base qw(Egypt::Extractor);

use File::Basename;
use File::Find;

sub new {
  my $package = shift;
  my @defaults = (
    model => Egypt::Model->new, # temporary (?)
  );
  return bless { @defaults, @_ }, $package;
}

sub feed {
  my ($self, $line) = @_;

  # function declarations
  if ($line =~ m/^;; Function (\S+)\s*$/) {
    # pre-gcc4 style
    $self->model->declare_function($self->current_module, $1);
    $self->{current_function} = $1;
  } elsif ($line =~ m/^;; Function (.*)\s+\((\S+)\)$/) {
    # gcc4 style
    $self->model->declare_function($self->current_module, $2, $1);
    $self->{current_function} = $2;
  }

  # function calls/uses
  if ($line =~ m/^.*\(call.*"(.*)".*$/) {
    # direct calls
    $self->model->add_call($self->current_function, $1, 'direct');
  } elsif ($line =~ m/^.*\(symbol_ref.*"(.*)".*<function_decl\s.*$/) {
    # indirect calls (e.g. use of function pointers)
    $self->model->add_call($self->current_function, $1, 'indirect');
  }

  # variable references
  if ($line =~ m/^.*\(symbol_ref.*"(.*)".*<var_decl\s.*$/) {
    $self->model->add_variable_use($self->current_function, $1);
  }

}

sub process {
  my $self = shift;
  my @files = ();
  foreach my $arg (@_) {
    if (-d $arg) {
      # directories
      $self->info("Traversing directory $arg ...");
      find(sub { push(@files, $File::Find::name) if basename($File::Find::name) =~ /\.(rtl|expand)$/  }, ($arg));
    } else {
      # files
      if (-r $arg) {
        push(@files, $arg);
      } else {
        $self->warning("$arg is not readable (or doesn't exist at all).");
      }
    }
  }

  if (scalar(@files) == 0) {
    $self->error("No readable input files!");
    exit(1);
  }

  foreach my $file (@files) {
    my $modulename = $file;
    $modulename =~ s/\.\d+r\.expand$//;
    $self->current_module($modulename);

    open FILE, '<', $file or die("Cannot read $file");
    while (<FILE>) {
      $self->feed($_);
    }
    close FILE;
  }
}

1;
