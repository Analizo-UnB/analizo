use strict;
use warnings;

use Test::More 'no_plan';

my $output;


# BEGIN test module declaration
use_ok('Egypt::Output::DOT');

# BEGIN test constructor
$output = new Egypt::Output::DOT;
isa_ok($output, 'Egypt::Output::DOT');

# BEGIN test output filename

can_ok($output, 'filename');

is(
  (new Egypt::Output::DOT(filename => 'test.dot'))->filename,
  'test.dot',
  'must store filename passed to constructor'
);

is(
  (new Egypt::Output::DOT)->filename,
  'output.dot',
  'must use "output.dot" as output filename by default'
);

$output = new Egypt::Output::DOT();
$output->filename('myfile.dot');
is(
  $output->filename(),
  'myfile.dot',
  'must be able to set output filename'
);

# BEGIN test empty call graph
$output = new Egypt::Output::DOT;
is(
  $output->string(),
  "digraph callgraph {\n}\n",
  'empty output must give empty digraph'
);

# BEGIN test listing calls
$output = new Egypt::Output::DOT;
$output->declare_function('module1', 'function1');
$output->declare_function('module1', 'function2');
$output->add_call('function1', 'function2', 'direct');
is(
  $output->string,
  'digraph callgraph {
"function1" -> "function2" [style=solid];
}
',
  'must generate correctly a graph with on call'
);

$output = new Egypt::Output::DOT;
$output->declare_function('module1', 'function1');
$output->declare_function('module1', 'function2');
$output->declare_function('module1', 'function3');
$output->add_call('function1', 'function2', 'direct');
$output->add_call('function1', 'function3', 'direct');
is(
  $output->string,
  'digraph callgraph {
"function1" -> "function2" [style=solid];
"function1" -> "function3" [style=solid];
}
',
  'must generate correctly a graph with f1 -> f2, f1 -> f3'
);

# BEGIN test indirect calls
$output = new Egypt::Output::DOT;
$output->declare_function('module1', 'function1');
$output->declare_function('module1', 'function2');
$output->declare_function('module1', 'function3');
$output->add_call('function1', 'function2', 'direct');
$output->add_call('function1', 'function3', 'indirect');
is(
  $output->string,
  'digraph callgraph {
"function1" -> "function2" [style=solid];
"function1" -> "function3" [style=dotted];
}
',
  'should distinguish direct from indirect calls'
);

# BEGIN test calls are direct by default

$output = new Egypt::Output::DOT;
$output->declare_function("module1", "function1");
$output->declare_function("module1", "function2");
$output->add_call('function1', 'function2');
is(
  $output->string,
  'digraph callgraph {
"function1" -> "function2" [style=solid];
}
',
  'must consider calls as direct by default'
);

# BEGIN test listing only defined functions
$output = new Egypt::Output::DOT;
$output->declare_function('module1', 'function1');
$output->declare_function('module2', 'function2');
$output->add_call('function1', 'function2');
$output->add_call('function2', 'function3');
is(
  $output->string,
  'digraph callgraph {
"function1" -> "function2" [style=solid];
}
',
  'must include by default only functions inside the project'
);

# BEGIN test omitting functions
$output = new Egypt::Output::DOT;
$output->declare_function('module1', 'function1');
$output->declare_function('module1', 'function2');
$output->declare_function('module1', 'function3');
$output->add_call('function1', 'function2');
$output->add_call('function1', 'function3');
$output->omit('function3');
is(
  $output->string,
  'digraph callgraph {
"function1" -> "function2" [style=solid];
}
',
  'must be able to omit a called function'
);

$output->omit('function1');
is(
  $output->string,
  'digraph callgraph {
}
',
  'must be able to omit a caller function'
);

# BEGIN test including external functions
$output = new Egypt::Output::DOT;
can_ok($output, 'include_externals');
$output->declare_function('module1', 'function1');
$output->add_call('function1', 'function2');
$output->include_externals(1);
is(
  $output->string,
  'digraph callgraph {
"function1" -> "function2" [style=solid];
}
',
  'must be able to omit a called function'
);

# BEGIN test demangle C++ methods
$output = new Egypt::Output::DOT;
$output->declare_function('module1', 'mangled1', 'demangled1');
$output->declare_function('module1', 'mangled2', 'demangled2');
$output->add_call('mangled1', 'mangled2');
is(
  $output->string,
  'digraph callgraph {
"demangled1" -> "demangled2" [style=solid];
}
',
  'must demangle function names in call output'
);

$output->cluster(1);
is(
  $output->string,
  'digraph callgraph {
subgraph "cluster_module1" {
  label "module1";
  node [label="demangled1"] "demangled1";
  node [label="demangled2"] "demangled2";
}
"demangled1" -> "demangled2" [style=solid];
}
',
  'must demangle function names in cluster declaration'
);


# TODO test removing implicit C++ function generated by the compiler.

# BEGIN test clustering
$output = new Egypt::Output::DOT;
can_ok($output, 'cluster');

$output->declare_function('cluster1.c.r1874.expand', 'function1');
$output->declare_function('cluster1.c.r1874.expand', 'function2');
$output->add_call('function1', 'function2', 'direct');
$output->cluster(1);
is(
  $output->string,
  'digraph callgraph {
subgraph "cluster_cluster1.c.r1874.expand" {
  label "cluster1.c";
  node [label="function1"] "function1";
  node [label="function2"] "function2";
}
"function1" -> "function2" [style=solid];
}
',
  "must output a single cluster"
);

$output = new Egypt::Output::DOT;
$output->cluster(1);
$output->declare_function('cluster1.c.r1874.expand', 'function1');
$output->declare_function('cluster2.c.r9873.expand', 'function2');
$output->declare_function('cluster2.c.r9873.expand', 'function3');
$output->add_call('function1', 'function2');
$output->add_call('function1', 'function3');
is(
  $output->string,
  'digraph callgraph {
subgraph "cluster_cluster1.c.r1874.expand" {
  label "cluster1.c";
  node [label="function1"] "function1";
}
subgraph "cluster_cluster2.c.r9873.expand" {
  label "cluster2.c";
  node [label="function2"] "function2";
  node [label="function3"] "function3";
}
"function1" -> "function2" [style=solid];
"function1" -> "function3" [style=solid];
}
',
  "must add two clusters in lexicographic order"
);

# BEGIN test grouping calls by module

can_ok($output, 'group_by_module');
$output->cluster(0);
$output->group_by_module(1);
is(
  $output->string,
  'digraph callgraph {
"cluster1.c" -> "cluster2.c" [style=solid,label=2];
}
',
  'must list correctly a single dependency arrow between two modules'
);

$output->add_call('function1', 'function4');
$output->declare_function('cluster3.c.r8773.expand', 'function4');
is(
  $output->string,
  'digraph callgraph {
"cluster1.c" -> "cluster2.c" [style=solid,label=2];
"cluster1.c" -> "cluster3.c" [style=solid,label=1];
}
',
  'must list arrow targets in lexicographic order'
);

$output->add_call('function5', 'function1');
$output->declare_function('cluster0.c.r7412.expand', 'function5');
is(
  $output->string,
  'digraph callgraph {
"cluster0.c" -> "cluster1.c" [style=solid,label=1];
"cluster1.c" -> "cluster2.c" [style=solid,label=2];
"cluster1.c" -> "cluster3.c" [style=solid,label=1];
}
',
  'must list arrow sources in in lexicographic order'
);

